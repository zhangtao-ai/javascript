<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0", user-scalable=no>
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script>
        // var radio = window.devicePixelRatio
        // var meta = document.querySelector("[name=viewport]");
        // meta.setAttribute("content",
        // `width=device-width,initial-scale=${1/radio},user-scalable=no`)
        document.documentElement.style.fontSize = window.innerWidth / 750 * 100 + "px"
    </script>
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        html{
            font-size: 100px;
        }
        .box{
            width: 7.5rem;
            height: 1rem;
            background-color: red;
        }
    </style>
</head>
<body>
    <div class="box">

    </div>
    <!-- <div style="border: 1px solid red;">
            <h2>上传图片</h2>
            <input type="file" id="file2" accept="image/*" onchange="uploadfile2()" multiple/>
            <div id="result2">
                <img src="" alt="" id="img" width="150" height="150">
            </div>
        </div> -->
    <script>
        //     function uploadfile2() {
        //     let reads = new FileReader();
        //     file = document.getElementById('file2').files[0];
        //     reads.readAsDataURL(file);
        //     console.log(reads);
        //     reads.onload = function (e) {
        //         document.getElementById('img').src = this.result;
        //     };
        // }
        //  let items = Array.of(2);
        //  console.log(items.length);
        //  console.log(items[0]);
        //转化为数组
        // function doSomething(){
        //     var args = Array.from(arguments);
        // }
        //映射转换
        // var helper = {
        //     diff:1,
        //     add(value){
        //         return value + this.diff;
        //     }
        // }
        // function translate(){
        //     return Array.from(arguments,helper.add,helper);
        // }
        // let numbers = translate(1,2,3);
        // console.log(numbers);
        //通过视图操作数据缓冲区
        // let buffer = new ArrayBuffer(10),
        //     view1 = new DataView(buffer),//覆盖所有字节
        //     view2 = new DataView(buffer,5,2);//覆盖索引5.6
        // console.log(view1.buffer === buffer);
        // console.log(view2.buffer === buffer);
        // console.log(view1.byteOffset);
        // console.log(view2.byteOffset);
        // console.log(view1.byteLength);
        // console.log(view2.byteLength);
        //读取写入数据
        // let buffer = new ArrayBuffer(2),
        //     view = new DataView(buffer);
        // view.setInt8(0,5);
        // view.setInt8(1,-1);
        // console.log(view.getInt16(0));
        // console.log(view.getInt8(0));
        // console.log(view.getInt8(1));
        //创建定型数组1
        // let buffer = new ArrayBuffer(10),
        //     view1 = new Int8Array(buffer),
        //     view2 = new Int8Array(buffer,5,2);
        // console.log(view1.buffer === buffer);
        // console.log(view2.buffer === buffer);
        // console.log(view1.byteOffset);
        // console.log(view2.byteOffset);
        // console.log(view1.byteLength);
        // console.log(view2.byteLength);
        //定型数组2
        // let ints = new Int16Array(2),
        //     floats = new Float32Array(5);
        // console.log(ints.byteLength);
        // console.log(ints.length);
        // console.log(floats.byteLength);
        // console.log(floats.length);
        //定型数组3
        // let ints1 = new Int16Array([25,50]),
        //     ints2 = new Int32Array(ints1);
        // console.log(ints1.buffer === ints2.buffer);
        // console.log(ints1.byteLength);
        // console.log(ints1.length);
        // console.log(ints1[0]);
        // console.log(ints1[1]);
        // console.log(ints2.byteLength);
        // console.log(ints2.length);
        // console.log(ints2[0]);
        // console.log(ints2[1]);
        // let ints = new Int16Array([25,50]);
        // let mapped = ints.map(function(v){
        //     return v*2;
        // })
        // console.log(mapped[0]);
        // console.log(mapped[1]);
        // console.log(mapped instanceof Int16Array);
        // let promise = new Promise(function(resove,reject){
        //     console.log("Promise");
        //     resove();
        // })
        // promise.then(function(){
        //     console.log("Resoved");
        // })
        // console.log("hi");
        // let promise = Promise.resolve(42);
        // promise.then(function(value){
        //     console.log(value)
        // })
        // let promise = Promise.reject(42);
        // promise.catch(function(value){
        //     console.log(value)
        // })
        //then对象转换成已完成的promise
        // let thenable = {
        //     then:function(resolve,reject){
        //         resolve(42);
        //     }
        // }
        // let p1 = Promise.resolve(thenable);
        // p1.then(function(value){
        //     console.log(value);
        // })
        //捕获错误
        // let p1 = new Promise(function(resolve,reject){
        //     resolve(42);
        // })
        // p1.then(function(value){
        //     throw new Error("boom");
        // }).catch(function(error){
        //     console.log(error.message);
        // })
        //都完成时返回的才会被完成，有一个拒绝立即被拒绝
        // let p1 = new Promise(function(resolve,reject){
        //     resolve(42);
        // })
        // let p2 = new Promise(function(resolve,reject){
        //     reject(43);
        // })
        // let p3 = new Promise(function(resolve,reject){
        //     resolve(44);
        // })
        // let p4 = Promise.all([p1,p2,p3])
        // p4.catch(function(value){
        //     console.log(Array.isArray(value))
        //     console.log(value)
        // })
        //哪一个先被解决，返回完成或解决promise
        // let p1 = Promise.resolve(42)
        // let p2 = new Promise(function(resolve,reject){
        //     reject(43);
        // })
        // let p3 = new Promise(function(resolve,reject){
        //     resolve(44);
        // })
        // let p4 = Promise.race([p1,p2,p3])
        // p4.then(function(value){
        //     console.log(Array.isArray(value))
        //     console.log(value)
        // })
        //基于promise的异步任务执行
        // let fs = require("fs")
        // function run(taskDef){
        //     let task = taskDef();
        //     let result = task.next();
        //     (function step(){
        //         if(!result.done){
        //             let promise = Promise.resolve(result.value);
        //             promise.then(function(value){
        //                 result = task.next(value);
        //                 step();
        //             }).catch(function(error){
        //                 result = task.throw(error);
        //                 step();
        //             })
        //         }
        //     }())
        // }
        // function readFile(filename){
        //     return new Promise(function(resolve,reject){
        //         fs.readFile(filename,function(err,contents){
        //             if(err){
        //                 reject(err);
        //             }else{
        //                 resolve(contents);
        //             }
        //         })
        //     })
        // }
        // run(function*(){
        //     let contents = yield readFile("config.json");
        //     doSomethingWith(contents);
        //     console.log("Done");
        // })
        //set陷阱验证属性
        // let target = {
        //     name:"target"
        // };
        // let proxy = new Proxy(target,{
        //     set(trapTarget,key,value,receiver){
        //         if(!trapTarget.hasOwnProperty(key)){
        //             if(isNaN(value)){
        //                 throw new TypeError("属性必须是数字")
        //             }
        //         }
        //         return Reflect.set(trapTarget,key,value,receiver);
        //     }
        // })
        // proxy.count = 1;
        // console.log(proxy.count);
        // console.log(target.count);
        // proxy.name = "proxy";
        // console.log(proxy.name);
        // console.log(target.name);
        // proxy.antherName = "proxy";
        //get陷阱验证对象结构
        // let proxy = new Proxy({},{
        //     get(trapTarget,key,receiver){
        //         if(!(key in receiver)){
        //             throw new TypeError("属性"+key+"不存在");
        //         }
        //         return Reflect.get(trapTarget,key,receiver);
        //     }
        // })
        // proxy.name = "proxy";
        // console.log(proxy.name);
        // console.log(proxy.nme);
        //has陷阱隐藏已有属性
        // let target = {
        //     name:"target",
        //     value:42
        // }
        // let proxy = new Proxy(target,{
        //     has(trapTarget,key){
        //         if(key === "value"){
        //             return false;
        //         }else{
        //             return Reflect.has(trapTarget,key)
        //         }
        //     }
        // })
        // console.log("value" in proxy);
        // console.log("name" in proxy);
        // console.log("toString" in proxy);
        //defineProperty防止删除属性
        //  let target = {
        //     name:"target",
        //     value:42
        // }
        // let proxy = new Proxy(target,{
        //     deleteProperty(trapTarget,key){
        //         if(key === "value"){
        //             return false;
        //         }else{
        //             return Reflect.defineProperty(trapTarget,key)
        //         }
        //     }
        // })
        // console.log("value" in proxy);
        // let result = delete proxy.value;
        // console.log("value" in proxy)
        //原型代理陷阱
        // let target = {};
        // let proxy = new Proxy(target,{
        //     getPrototypeOf(trapTarget){
        //         return null
        //     },
        //     setPrototypeOf(trapTarget,proto){
        //         return false
        //     }
        // })
        // let targetProto = Object.getPrototypeOf(target);
        // let proxyProto = Object.getPrototypeOf(proxy);
    </script>
</body>
</html>